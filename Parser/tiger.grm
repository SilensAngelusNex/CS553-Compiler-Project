%%
%term
    EOF
  | ID of string
  | INT of int | STRING of string
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK
  | LBRACE | RBRACE | DOT
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF
  | BREAK | NIL
  | FUNCTION | VAR | TYPE | UMINUS

%nonterm  exp | program
        | dec | varDec | funcDec | typeDec | ty | argDef
        | seqExp | sequence
        | boolExp | compExp | addExp | multExp | parenExp | comparator | infix | infixOp | term | lvalue
        | ifExp | whileExp | forExp | letExp
        | arrCreate | recCreate | fields
        | callExp | params | assignExp

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE
	DO OF NIL

%prefer THEN ELSE LPAREN


%value ID ("bogus")
%value INT (1)
%value STRING ("")

%change EQ -> ASSIGN
        | ASSIGN -> EQ
        | SEMICOLON ELSE -> ELSE
        |   -> IN INT END

%nonassoc THEN
%nonassoc ELSE

%left ASSIGN OF DO
    (* Of precedence is used to override subscript vs. array creation*)
    (* I'm unsure which direction for DO!!! If the lookahead token at this point is a binary operator, the parser doesn't know whether to shift the operator, making the trailing exp in the  WHILE expression longer, or to immediately reduce the WHILE. Obviously (to us, not to bison), the solution is to shift. bison doesn't know that because the production exp: WHILE exp DO exp doesn't have a precedence. The precedence of that production would be the precedence of its last terminal, which is DO, so the simple solution is to define a precedence for DO *)
    (*left is in favor of shifting! right is in favor or reducing *)
%left OR
%left AND
%left EQ NEQ GT GE LT LE
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS

%%

(* This is a skeleton grammar file, meant to illustrate what kind of
 * declarations are necessary above the %% mark.  Students are expected
 *  to replace the two dummy productions below with an actual grammar.
 *)

program	: exp        			    ()

exp : exp PLUS exp                  ()
    | exp MINUS exp                 ()
    | exp DIVIDE exp                ()
    | exp TIMES exp                 ()
    | exp EQ exp                    ()
    | exp NEQ exp                   ()
    | exp GT exp                    ()
    | exp GE exp                    ()
    | exp LT exp                    ()
    | exp LE exp                    ()
    | exp AND exp                   ()
    | exp OR exp                    ()
    | MINUS exp      %prec UMINUS   ()
    | ifExp                         ()
    | letExp                        ()
    | forExp                        ()
    | whileExp                      ()
    | seqExp                        ()
    | callExp                       ()
    | assignExp                     ()
    | recCreate                     ()
    | arrCreate                     ()
    | INT                           ()
    | STRING                        ()
    | NIL                           ()
    | BREAK                         ()
    | lvalue                        ()


(**                      *
 *                       *
 * Compound Expressions  *
 *                       *
 *                      **)

ifExp : IF exp THEN exp         %prec THEN  ()
      | IF exp THEN exp ELSE exp            ()


letExp : LET dec IN seqExp END              ()

whileExp : WHILE exp DO exp                 ()

forExp : FOR ID ASSIGN exp TO exp DO exp    ()

(**                      *
 *                       *
 *          Usage        *
 *                       *
 *                       **)

callExp : ID LPAREN exp params          ()
        | ID LPAREN RPAREN              ()

params : COMMA exp params               ()
       | RPAREN                         ()

assignExp : lvalue ASSIGN exp           ()

seqExp : LPAREN exp sequence            ()
       | LPAREN RPAREN                  ()

sequence : SEMICOLON exp sequence       ()
         | RPAREN                       ()


(**                      *
  *                       *
  *       Creation        *
  *                       *
  *                      **)

arrCreate : lvalue OF exp ()

(*

ID LBRACK exp RBRACK this is exactly an lvalue --> prec on OF :: still 1

I have decided to change this to simply accept an lvalue and we will address it in the semantic analysis

*)

recCreate : ID LBRACE ID EQ exp fields  ()
          | ID LBRACE RBRACE            ()

fields : COMMA ID EQ exp                ()
       | RBRACE                         ()
(**                      *
 *                       *
 *      Declarations     *
 *                       *
 *                      **)

dec : varDec dec                        ()
    | funcDec dec                       ()
    | typeDec dec                       ()

varDec : VAR ID ASSIGN exp              ()
       | VAR ID COLON ID ASSIGN exp     ()

funcDec : FUNCTION ID LPAREN argDef RPAREN COLON ID EQ exp  ()
        | FUNCTION ID LPAREN RPAREN COLON ID EQ exp         ()
        | FUNCTION ID LPAREN argDef RPAREN EQ exp           ()
        | FUNCTION ID LPAREN RPAREN EQ exp                  ()

typeDec : TYPE ID EQ ty             ()

ty   : ID                           ()
     | ARRAY OF ty                  ()
     | LBRACE argDef RBRACE         ()

argDef : ID COLON ty COMMA argDef   ()
       | ID COLON ty                ()

lvalue : lvalue LBRACK exp RBRACK   () (* subscript *)
       | lvalue DOT ID              () (* field expression *)
       | ID                         ()
